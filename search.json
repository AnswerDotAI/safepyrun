[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "safepython",
    "section": "",
    "text": "_find_frame_dict walks the call stack looking for a frame whose globals contain sentinel. This lets RunPython find the caller’s namespace without requiring an explicit globals dict. If no sentinel is found, it falls back to its own module globals.\n\n_test_sentinel = True\nd = _find_frame_dict('_test_sentinel')\nassert '_test_sentinel' in d\nd2 = _find_frame_dict('nonexistent_sentinel_xyz')\nassert d2 is not None\n\n\nsource\n\n\n\ndef find_var(\n    var:str\n):\n\nSearch for var in all frames of the call stack\n\nfind_var('_test_sentinel')\n\nTrue\n\n\n\nsource\n\n\n\n\ndef allow(\n    c:VAR_POSITIONAL\n):\n\n__pytools__ is the set of callable names that the sandbox allows. allow registers new entries — it accepts bare strings (for module-qualified names like 'numpy.array') or dicts mapping a class/module to a list of method names (which generates 'ClassName.method' keys).\n\nassert 'pyrun' in __pytools__\nallow('my_test_func')\nassert 'my_test_func' in __pytools__\nallow({str: ['zfill']})\nassert 'str.zfill' in __pytools__\n__pytools__.discard('my_test_func')\nassert 'str.zfill' in __pytools__",
    "crumbs": [
      "safepython"
    ]
  },
  {
    "objectID": "core.html#helpers-and-setup",
    "href": "core.html#helpers-and-setup",
    "title": "safepython",
    "section": "",
    "text": "_find_frame_dict walks the call stack looking for a frame whose globals contain sentinel. This lets RunPython find the caller’s namespace without requiring an explicit globals dict. If no sentinel is found, it falls back to its own module globals.\n\n_test_sentinel = True\nd = _find_frame_dict('_test_sentinel')\nassert '_test_sentinel' in d\nd2 = _find_frame_dict('nonexistent_sentinel_xyz')\nassert d2 is not None\n\n\nsource\n\n\n\ndef find_var(\n    var:str\n):\n\nSearch for var in all frames of the call stack\n\nfind_var('_test_sentinel')\n\nTrue\n\n\n\nsource\n\n\n\n\ndef allow(\n    c:VAR_POSITIONAL\n):\n\n__pytools__ is the set of callable names that the sandbox allows. allow registers new entries — it accepts bare strings (for module-qualified names like 'numpy.array') or dicts mapping a class/module to a list of method names (which generates 'ClassName.method' keys).\n\nassert 'pyrun' in __pytools__\nallow('my_test_func')\nassert 'my_test_func' in __pytools__\nallow({str: ['zfill']})\nassert 'str.zfill' in __pytools__\n__pytools__.discard('my_test_func')\nassert 'str.zfill' in __pytools__",
    "crumbs": [
      "safepython"
    ]
  },
  {
    "objectID": "core.html#write-policies",
    "href": "core.html#write-policies",
    "title": "safepython",
    "section": "Write policies",
    "text": "Write policies\n\nsource\n\nchk_dest\n\ndef chk_dest(\n    p, ok_dests\n):\n\nchk_dest resolves a path and verifies it falls under one of the allowed destination prefixes. Raises PermissionError if not. Used by all WritePolicy subclasses.\n\nchk_dest('/tmp/foo.txt', ['/tmp'])\ntry: chk_dest('/etc/passwd', ['/tmp'])\nexcept PermissionError: print(\"Correctly blocked /etc/passwd\")\n\nCorrectly blocked /etc/passwd\n\n\n\nsource\n\n\nOpenWritePolicy\n\ndef OpenWritePolicy(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nCheck open() only when mode is writable\n\nsource\n\n\nPathWritePolicy\n\ndef PathWritePolicy(\n    target_pos:NoneType=None, target_kw:NoneType=None\n):\n\nCheck resolved Path self, optionally also target args\n\nsource\n\n\nPosWritePolicy\n\ndef PosWritePolicy(\n    pos:int=0, kw:NoneType=None\n):\n\nCheck positional/keyword arg is an allowed write destination\n\nsource\n\n\nWritePolicy\n\ndef WritePolicy(\n    args:VAR_POSITIONAL, kwargs:VAR_KEYWORD\n):\n\nBase for write destination policies\nThree WritePolicy subclasses handle different write-checking patterns.\n\npp = PosWritePolicy(1, 'dst')\npp.check(None, ['src', '/tmp/ok'], {}, ['/tmp'])\ntry: pp.check(None, ['src', '/root/bad'], {}, ['/tmp'])\nexcept PermissionError: print(\"PosWritePolicy blocked /root/bad\")\n\npwp = PathWritePolicy()\npwp.check(Path('/tmp/f.txt'), [], {}, ['/tmp'])\ntry: pwp.check(Path('/etc/f.txt'), [], {}, ['/tmp'])\nexcept PermissionError: print(\"PathWritePolicy blocked /etc/f.txt\")\n\nowp = OpenWritePolicy()\nowp.check(None, ['/tmp/f.txt', 'w'], {}, ['/tmp'])\nowp.check(None, ['/etc/passwd', 'r'], {}, ['/tmp'])\ntry: owp.check(None, ['/root/f.txt', 'w'], {}, ['/tmp'])\nexcept PermissionError: print(\"OpenWritePolicy blocked write to /root/f.txt\")\n\nPosWritePolicy blocked /root/bad\nPathWritePolicy blocked /etc/f.txt\nOpenWritePolicy blocked write to /root/f.txt\n\n\n\nsource\n\n\nallow_write\n\ndef allow_write(\n    policies\n):\n\nRegister write policies for method/function names\n__pytools_write__ maps qualified callable names (like 'Path.write_text') to WritePolicy objects. allow_write registers these policies. When ok_dests is set, _safe_getattr checks this registry and wraps matching callables with _WriteChecked to enforce destination validation before the call.\n\nallow_write({'test.Method': WritePolicy()})\nassert 'test.Method' in __pytools_write__\ndel __pytools_write__['test.Method']\n\n_WriteChecked wraps a method so that its WritePolicy is enforced before the actual call. Returned by _safe_getattr when a callable matches a __pytools_write__ entry and ok_dests is set.\n\nwc = _WriteChecked(Path('/tmp'), Path.exists, PathWritePolicy(), ['/tmp'])\nassert callable(wc)\nwc2 = _WriteChecked(Path('/etc'), Path('/etc').exists, PathWritePolicy(), ['/tmp'])\ntry: wc2()\nexcept PermissionError: print(\"WriteChecked correctly blocked /etc\")\n\nWriteChecked correctly blocked /etc\n\n\n_safe_open returns a closure that checks OpenWritePolicy before delegating to the real open. Only injected into the sandbox builtins when ok_dests is set — otherwise the default open (which is already excluded from all_builtins) is not available.\n\nso = _safe_open(['/tmp'])\nf = so('/tmp/test_safe_open.txt', 'w')\nf.write('test'); f.close()\nso('/etc/passwd', 'r').close()\ntry: so('/etc/bad.txt', 'w')\nexcept PermissionError: print(\"_safe_open correctly blocked write to /etc\")\n\n_safe_open correctly blocked write to /etc",
    "crumbs": [
      "safepython"
    ]
  },
  {
    "objectID": "core.html#builtins-and-wrappers",
    "href": "core.html#builtins-and-wrappers",
    "title": "safepython",
    "section": "Builtins and wrappers",
    "text": "Builtins and wrappers\nall_builtins merges RestrictedPython’s safe_builtins, utility_builtins, limited_builtins, and async support, then adds the core container types (dict, list, set, tuple, frozenset) and __import__. This is the builtins dict passed to the sandbox — anything not in here is inaccessible as a builtin.\n\nassert all_builtins['dict'] is dict\nassert all_builtins['list'] is list\nassert '__import__' in all_builtins\nassert 'eval' not in all_builtins\nassert 'exec' not in all_builtins\nlist(all_builtins.keys())[:5]\n\n['__build_class__', 'None', 'False', 'True', 'abs']\n\n\n_make_safe_getattr returns a closure over ok_dests that intercepts every attribute access. For callables, it checks __pytools_write__ first (wrapping with _WriteChecked if matched), then falls back to the __llmtools__|__pytools__ allow-set. Non-callables pass through unchecked.\n\nga = _make_safe_getattr(ok_dests=['/tmp'])\nassert ga('hello', 'zfill')(10) == '00000hello'\n\n_DirectPrint is a no-op wrapper that RestrictedPython’s _print_ and _print hooks delegate to. It simply calls the real print, bypassing RestrictedPython’s default print interception.\n_Uncallable wraps a callable to raise PermissionError on call, while still exposing its non-callable attributes (like __name__). This lets the sandbox expose objects for inspection without letting users invoke them.\n_callable_ok checks whether a callable should be allowed — it’s ok if its name ends with _ (user-exported), is in the allow-set directly, or its module.qualname is registered.\n\nuc = _Uncallable(len, 'len')\nassert repr(uc) == repr(len)\ntry: uc([1,2,3])\nexcept PermissionError: print(\"_Uncallable correctly blocked call to len\")\n\n_ok = {'test_func_'}\nassert _callable_ok('test_func_', lambda: None, _ok)\nassert not _callable_ok('secret', lambda: None, _ok)\nassert not _callable_ok('_private', lambda: None, _ok)\n\n_Uncallable correctly blocked call to len\n\n\n\nsource\n\nSafeTransformer\n\ndef SafeTransformer(\n    errors:NoneType=None, warnings:NoneType=None, used_names:NoneType=None\n):\n\nA :class:NodeVisitor subclass that walks the abstract syntax tree and allows modification of nodes.\nThe NodeTransformer will walk the AST and use the return value of the visitor methods to replace or remove the old node. If the return value of the visitor method is None, the node will be removed from its location, otherwise it is replaced with the return value. The return value may be the original node in which case no replacement takes place.\nHere is an example transformer that rewrites all occurrences of name lookups (foo) to data['foo']::\nclass RewriteName(NodeTransformer):\n   def visit_Name(self, node):\n       return Subscript(\n           value=Name(id='data', ctx=Load()),\n           slice=Constant(value=node.id),\n           ctx=node.ctx\n       )\nKeep in mind that if the node you’re operating on has child nodes you must either transform the child nodes yourself or call the :meth:generic_visit method for the node first.\nFor nodes that were part of a collection of statements (that applies to all statement nodes), the visitor may also return a list of nodes rather than just a single node.\nUsually you use the transformer like this::\nnode = YourTransformer().visit(node)\nSafeTransformer extends RestrictedPython’s RestrictingNodeTransformer to rewrite attribute access. Loads become _getattr_(obj, name) calls (enabling callable checks), stores/deletes become _write_(obj).attr = val (enabling mutation control). Private attrs (starting with _) are blocked except for a curated ALLOWED_DUNDERS set.",
    "crumbs": [
      "safepython"
    ]
  },
  {
    "objectID": "core.html#main-implementation",
    "href": "core.html#main-implementation",
    "title": "safepython",
    "section": "Main implementation",
    "text": "Main implementation\n_run_python is the core sandbox executor. It compiles code with SafeTransformer, sets up the restricted globals (builtins, getattr hook, tools), handles the last-expression-as-return-value pattern, captures stdout/stderr, and exports _-suffixed locals back to the caller’s namespace.\n\nsource\n\nRunPython\n\ndef RunPython(\n    g:NoneType=None, sentinel:NoneType=None, ok_dests:NoneType=None\n):\n\nInitialize self. See help(type(self)) for accurate signature.\nRunPython is the public API. It captures the caller’s globals via _find_frame_dict, optionally takes ok_dests for write-checking, and generates its docstring dynamically from the current __llmtools__|__pytools__ set so the LLM always sees an up-to-date tool list.\n\npyrun = RunPython()\n\n\nawait pyrun('[]')\n\n[]\n\n\n\nawait pyrun(\"print('tt')\")\n\n'tt\\n'\n\n\n\nawait pyrun(\"print('tt')\", concise=False)\n\n{'stdout': 'tt\\n'}\n\n\n\n# Unpacking is allowed\nawait pyrun(\"\"\"\na = [1,2,3]\nprint(*a)\n\"\"\")\n\n'1 2 3\\n'\n\n\n\ndef f(): warnings.warn('a warning')\nallow('f')\nawait pyrun('print(\"asdf\"); f(); 1+1')\n\n{'stdout': 'asdf\\n',\n 'stderr': \"/var/folders/51/b2_szf2945n072c0vj2cyty40000gn/T/ipykernel_24286/3774884187.py:1: UserWarning: a warning\\n  def f(): warnings.warn('a warning')\\n\",\n 'result': 2}",
    "crumbs": [
      "safepython"
    ]
  },
  {
    "objectID": "core.html#standard-allows",
    "href": "core.html#standard-allows",
    "title": "safepython",
    "section": "Standard allows",
    "text": "Standard allows\n\nsource\n\nsafe_type\n\ndef safe_type(\n    o:object\n):\n\nSame as type(o)",
    "crumbs": [
      "safepython"
    ]
  },
  {
    "objectID": "core.html#config",
    "href": "core.html#config",
    "title": "safepython",
    "section": "Config",
    "text": "Config\nsafepyrun loads an optional user config from {xdg_config_home}/safepyrun/config.py at import time, after all defaults are registered. This lets users permanently extend the sandbox allowlists without modifying the package. The config file is executed with all safepyrun.core globals already available — no imports needed. This includes allow, allow_write, WritePolicy, PathWritePolicy, PosWritePolicy, OpenWritePolicy, and all standard library modules already imported by the module.\nExample ~/.config/safepyrun/config.py (Linux) or ~/Library/Application Support/safepyrun/config.py (macOS):\n# Add pandas tools\nallow({pandas.DataFrame: ['head', 'describe', 'info', 'shape']})\n\n# Allow writing to ~/data\nallow_write({'Path.write_text': PathWritePolicy()})\nIf the config file has errors, a warning is emitted and the defaults remain intact.",
    "crumbs": [
      "safepython"
    ]
  },
  {
    "objectID": "core.html#examples",
    "href": "core.html#examples",
    "title": "safepython",
    "section": "Examples",
    "text": "Examples\n\nawait pyrun('''\na = {\"b\":1}\nlist(a.items())\n''')\n\n[('b', 1)]\n\n\n\nawait pyrun('Path().exists()')\n\nTrue\n\n\n\nawait pyrun(\"os.path.join('/foo', 'bar', 'baz.py')\")\n\n'/foo/bar/baz.py'\n\n\n\nawait pyrun('a_=3')\na_\n\n3\n\n\n\nawait pyrun('''aa_='33' ''')\nawait pyrun('''len(aa_) ''')\n\n2\n\n\n\ndef g(): ...\n\n\nawait pyrun('inspect.getsource(g)')\n\n'def g(): ...\\n'\n\n\n\ntry: await pyrun('g()')\nexcept PermissionError: print(\"Correct exception raised\")\nelse: raise Exception(\"No exception\")\n\nCorrect exception raised\n\n\n\nawait pyrun('re.compile(\"a\")')\n\nre.compile(r'a', re.UNICODE)\n\n\n\nfrom re import compile\n\n\nawait pyrun('compile(\"a\")')\n\nre.compile(r'a', re.UNICODE)\n\n\n\nawait pyrun('''\ndict(a=safe_type(1))\n''')\n\n{'a': int}\n\n\n\nawait pyrun(\"\"\"\nasync def agen():\n    for x in [1,2]: yield x\nres = []\nasync for x in agen(): res.append(x)\nres\n\"\"\")\n\n[1, 2]\n\n\n\nawait pyrun('''\nimport asyncio\nasync def fetch(n): return n * 10\nprint(string.ascii_letters)\nawait asyncio.gather(fetch(1), fetch(2), fetch(3))\n''')\n\n{'stdout': 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\n',\n 'result': [10, 20, 30]}\n\n\n\nimport numpy as np\n\n\nallow('numpy.array', 'numpy.ndarray.sum')\nawait pyrun('import numpy as np; np.array([1,2,3]).sum()')\n\n6\n\n\n\nWrite policy examples\n\npyrun2 = RunPython(ok_dests=['/tmp'])\n\n\nawait pyrun2(\"Path('/tmp/test_write.txt').write_text('hello')\")\n\n5\n\n\n\ntry: await pyrun2(\"Path('/etc/evil.txt').write_text('bad')\")\nexcept PermissionError as e: print(f'Blocked: {e}')\n\nBlocked: Write to '/etc/evil.txt' not allowed; permitted: ['/tmp']\n\n\n\nawait pyrun2(\"open('/tmp/test_open.txt', 'w').write('hi')\")\n\n2\n\n\n\ntry: await pyrun2(\"open('/root/bad.txt', 'w')\")\nexcept PermissionError as e: print(f'Blocked: {e}')\n\nBlocked: Write to '/root/bad.txt' not allowed; permitted: ['/tmp']\n\n\n\nawait pyrun2(\"open('/etc/passwd', 'r').read(10)\")\n\n'##\\n# User '\n\n\n\nawait pyrun2(\"import shutil; shutil.copy('/tmp/test_write.txt', '/tmp/test_copy.txt')\")\n\n'/tmp/test_copy.txt'\n\n\n\ntry: await pyrun2(\"import shutil; shutil.copy('/tmp/test_write.txt', '/root/bad.txt')\")\nexcept PermissionError as e: print(f'Blocked: {e}')\n\nBlocked: Write to '/root/bad.txt' not allowed; permitted: ['/tmp']\n\n\n\ntry: await pyrun(\"Path('/tmp/test.txt').write_text('nope')\")\nexcept AttributeError as e: print(f'No ok_dests: {e}')\n\nNo ok_dests: Cannot access callable: write_text\n\n\n\npyrun_cwd = RunPython(ok_dests=['.'])\n\n# Writing to cwd should work\nawait pyrun_cwd(\"Path('test_cwd_ok.txt').write_text('hello')\")\n\n5\n\n\n\nPath('test_cwd_ok.txt').unlink(missing_ok=True)\n\n\n# Writing to /tmp should be blocked (not in ok_dests)\ntry: await pyrun_cwd(\"Path('/tmp/nope.txt').write_text('bad')\")\nexcept PermissionError: print(\"Blocked /tmp as expected\")\n\nBlocked /tmp as expected\n\n\n\n# Parent traversal should be blocked\ntry: await pyrun_cwd(\"Path('../escape.txt').write_text('bad')\")\nexcept PermissionError: print(\"Blocked ../ as expected\")\n\nBlocked ../ as expected\n\n\n\n# Sneaky traversal via subdir/../../ should also be blocked\ntry: await pyrun_cwd(\"Path('subdir/../../escape.txt').write_text('bad')\")\nexcept PermissionError: print(\"Blocked subdir/../../ as expected\")\n\nBlocked subdir/../../ as expected\n\n\n\ntry: await pyrun_cwd(\"open('../bad_open.txt', 'w')\")\nexcept PermissionError: print(\"Blocked open ../ as expected\")\n\nBlocked open ../ as expected",
    "crumbs": [
      "safepython"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "safepyrun",
    "section": "",
    "text": "safepyrun is an allowlist-based Python sandbox that lets LLMs execute code safely(ish) in your real environment. Instead of isolating code in a container (which cuts it off from the libraries, data, and tools it actually needs) safepyrun runs in-process with controlled access to a curated subset of Python’s stdlib, plus any functions you explicitly opt in.\nIt’s the Python counterpart to safecmd, which does much the same thing for bash.",
    "crumbs": [
      "safepyrun"
    ]
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "safepyrun",
    "section": "Installation",
    "text": "Installation\nInstall from pypi\n$ pip install safepyrun",
    "crumbs": [
      "safepyrun"
    ]
  },
  {
    "objectID": "index.html#background",
    "href": "index.html#background",
    "title": "safepyrun",
    "section": "Background",
    "text": "Background\nWhen an LLM needs to run code on your behalf, the standard advice is to sandbox it in a container. The problem is that the whole reason you want the LLM running code is so it can interact with your environment – your files, your libraries, your running processes, your data. A containerised sandbox either can’t access any of that, or it requires complex volume mounts and dependency mirroring that recreate your environment inside the container.\nYou could just exec the LLM’s code directly in your process, which would give full access to everything… but “everything” includes shutil.rmtree, os.remove, subprocess.run(\"rm -rf /\"), etc!\nsafepyrun takes a middle path. It runs the LLM’s code in your real Python process, with access to your real objects, but interposes an allowlist that controls which callables are accessible. The curated default list covers a large and useful subset of the standard library (string manipulation, math, JSON parsing, path inspection, data structures, and so on) while excluding anything that writes to the filesystem, spawns processes, or modifies system state. You can extend the list for your own functions.\nThe mechanism behind safepyrun is RestrictedPython, a long-standing project that compiles Python source code into a modified AST (Abstract Syntax Tree) where every attribute access, item access, and iteration is routed through hook functions. This means that when the LLM’s code does obj.method(), it doesn’t go directly to method – it goes through a gatekeeper that checks whether that callable is on the allowlist. The same applies to getattr, getitem, and iter, so there’s no easy way to accidentally reach a dangerous function through indirect access. safepyrun supplies these hook functions, wiring them up to an allowlist of permitted callables.\nBecause a lot of modern Python code (and many LLM tool-calling frameworks) is async, safepyrun also depends on restrictedpython-async, which extends RestrictedPython to handle await, async for, and async with expressions.\nA lot of the online discussion around RestrictedPython suggests it’s not really useful for sandboxing, and that’s true if you’re trying to block a determined adversary. But an LLM is not a determined adversary. It’s a well-meaning but occasionally clumsy collaborator. The threat model is completely different: you don’t need to prevent deliberate escape attempts, you need to make it very unlikely that a hallucinated cleanup step or a misunderstood request causes damage. This is the same “safe-ish” philosophy used in safecmd for bash.\nOnce you internalise this, the design space opens up. It’s actually fine for the LLM to read files, access the internet via httpx, parse data, and call into your libraries. The things you want to prevent are writes to the filesystem, spawning processes, and overwriting important state. RestrictedPython gives us the mechanism to enforce this: it rewrites the AST to intercept attribute access, iteration, and item access, so that every callable goes through an allowlist check.\nThe allowlist has three tiers. First, a curated subset of the standard library that has been audited once so every user doesn’t have to repeat the work: things like re, json, itertools, math, collections, pathlib (read-only methods), and many more. Second, user-extended functions registered via allow(), so you can opt in your own project’s functions and methods. Third, an LLM self-service mechanism: any symbol the LLM creates with a trailing underscore (like helper_) is automatically available in subsequent calls, letting it build up reusable utilities across a multi-step tool loop.",
    "crumbs": [
      "safepyrun"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "safepyrun",
    "section": "Usage",
    "text": "Usage\n\nfrom safepyrun import *\n\nThe main entry point is pyrun = RunPython(), which returns an async function that takes a string of Python code and executes it in the sandbox. The last expression in the code is returned as the result, and any print() output is captured separately. Errors are caught and reported rather than crashing the caller.\n\npyrun = RunPython()\n\n\nawait pyrun('1+1')\n\n{'result': 2}\n\n\nYou can mix print() output with a return value. The printed output goes to the stdout key, and the last expression becomes result:\n\nawait pyrun('print(\"hello\"); 1+1')\n\n{'stdout': 'hello\\n', 'result': 2}\n\n\nModules can be imported. stderr is also captured:\n\nawait pyrun('''\nimport warnings\nwarnings.warn('a warning')\n\"ok\"\n''')\n\n{'stderr': '&lt;tool&gt;:2: UserWarning: a warning\\n', 'result': 'ok'}\n\n\nA large subset of the standard library is available out of the box – things like re, json, math, itertools, collections, pathlib (read-only methods), and many more. These have been audited once so that every user doesn’t have to repeat the work:\n\nawait pyrun('import re; re.findall(r\"\\\\d+\", \"there are 3 cats and 10 dogs\")')\n\n{'result': ['3', '10']}\n\n\nThe default allowlist covers text and data processing (re, json, csv, html, textwrap, string, difflib, unicodedata), math and numerics (math, cmath, statistics, decimal, fractions, random, operator), data structures (collections, heapq, bisect, plus methods on all the built-in types), iteration and functional tools (itertools, functools), read-only filesystem access (pathlib, os.path, fnmatch), date and time (datetime, time), URL handling and read-only HTTP (urllib.parse, httpx.get, ipaddress), encoding and serialization (base64, binascii, hashlib, zlib, pickle, struct), introspection (inspect, ast, keyword, sys.getsizeof), XML parsing (xml.etree.ElementTree), and various utilities (contextlib, copy, dataclasses, enum, secrets, uuid, pprint, shlex, colorsys, traceback).\n\nThe allow() function\nFunctions you define yourself or import from third-party packages are not automatically available. If the sandbox encounters an unregistered callable, it raises an error.\nTo make a function available, register it with allow():\n\ndef greet(name): return f\"Hello, {name}!\"\n\n\nallow('greet')\nawait pyrun('greet(\"World\")')\n\n{'result': 'Hello, World!'}\n\n\nThe same applies to anything you import from PyPI. For instance, if you wanted the LLM to be able to call numpy.array, you would register it with allow('numpy.array').\nallow() accepts two forms: strings and dicts. The simplest form is a bare string, which registers a single name. This works for standalone functions in the caller’s namespace:\n\ndef double(x): return x * 2\nallow('double')\nawait pyrun('double(21)')\n\n{'result': 42}\n\n\nFor methods on modules or classes, use dotted string syntax. The string should match how the sandbox will look up the callable, which is ClassName.method or module.function:\n\nimport numpy as np\n\n\nallow('numpy.array', 'numpy.ndarray.sum')\nawait pyrun('np.array([1,2,3]).sum()')\n\n{'result': 6}\n\n\nNote that the string must use the actual class or module name as it appears in Python, not the alias. In the example above, even though the sandbox code uses np, the allowlist entry is 'numpy.array' because numpy is the module’s real name.\nThe dict form is a convenient shorthand for registering multiple methods on the same module or class at once. The key is the actual module or class object, and the value is a list of method name strings:\n\nallow({np.ndarray: ['mean', 'reshape', 'tolist']})\nawait pyrun('np.array([1,2,3,4]).reshape(2,2).mean()')\n\n{'result': 2.5}\n\n\nThe dict form does two things: it registers the class/module name itself (so it can be called as a constructor or accessed as a namespace), and it registers each ClassName.method pair. You can mix strings and dicts in a single allow() call:\nallow('my_func', {np.linalg: ['norm', 'det']})\n\n\nThe _ suffix convention\nThere’s a third way callables become available in the sandbox: any symbol the LLM creates whose name ends with _ (but doesn’t start with _) is automatically exported back to the caller’s namespace, and is available in subsequent pyrun calls. This means the LLM can build up reusable helper functions across a multi-step tool loop without requiring the user to register anything:\n\nawait pyrun('def clean_(s): return s.strip().lower()')\n\n\nawait pyrun('clean_(\"  Hello World  \")')\n\n{'result': 'hello world'}\n\n\nThe exported symbols are real objects in your namespace, not just available inside the sandbox. This works for variables too, not just functions:\n\nawait pyrun('result_ = [x**2 for x in range(5)]')\nresult_\n\n[0, 1, 4, 9, 16]\n\n\nThis is particularly useful in LLM tool loops where the model might need to define a parsing function in one step and reuse it in several subsequent steps. Non-suffixed names remain local to the sandbox call and are not exported.\n\n\nAsync support\nThe sandbox is async-native. If the code being executed contains await, async for, or async with expressions, they work as expected. Many modern Python libraries and LLM tool-calling frameworks are async, and you want the sandbox to be able to call into them without workarounds.\n\nawait pyrun('''\nimport asyncio\nasync def fetch(n): return n * 10\nawait asyncio.gather(fetch(1), fetch(2), fetch(3))\n''')\n\n{'result': [10, 20, 30]}",
    "crumbs": [
      "safepyrun"
    ]
  },
  {
    "objectID": "index.html#writable-path-permissions",
    "href": "index.html#writable-path-permissions",
    "title": "safepyrun",
    "section": "Writable path permissions",
    "text": "Writable path permissions\nBy default, RunPython blocks all filesystem writes. To enable controlled writing, pass ok_dests — a list of directory prefixes where writes are permitted. Writing to an allowed destination works normally, but writing anywhere else raises PermissionError:\n\npyrun2 = RunPython(ok_dests=['/tmp'])\n\n\nfrom pathlib import Path\n\n\nawait pyrun2(\"Path('/tmp/test_write.txt').write_text('hello')\")\n\n{'result': 5}\n\n\n\ntry: await pyrun2(\"Path('/etc/evil.txt').write_text('bad')\")\nexcept PermissionError as e: print(f'Blocked: {e}')\n\nBlocked: Write to '/etc/evil.txt' not allowed; permitted: ['/tmp']\n\n\nThe same permission checking applies to open() in write mode, not just Path methods:\n\nawait pyrun2(\"open('/tmp/test_open.txt', 'w').write('hi')\")\n\n{'result': 2}\n\n\n\ntry: await pyrun2(\"open('/root/bad.txt', 'w')\")\nexcept PermissionError as e: print(f'Blocked: {e}')\n\nBlocked: Write to '/root/bad.txt' not allowed; permitted: ['/tmp']\n\n\nRead access is unaffected — only writes are gated:\n\nawait pyrun2(\"open('/etc/passwd', 'r').read(10)\")\n\n{'result': '##\\n# User '}\n\n\nHigher-level file operations like shutil.copy are also intercepted. The destination is checked against ok_dests:\n\nawait pyrun2(\"import shutil; shutil.copy('/tmp/test_write.txt', '/tmp/test_copy.txt')\")\n\n{'result': '/tmp/test_copy.txt'}\n\n\n\ntry: await pyrun2(\"import shutil; shutil.copy('/tmp/test_write.txt', '/root/bad.txt')\")\nexcept PermissionError as e: print(f'Blocked: {e}')\n\nBlocked: Write to '/root/bad.txt' not allowed; permitted: ['/tmp']\n\n\nWithout ok_dests, the default RunPython instance blocks all write operations entirely — Path.write_text isn’t even callable:\n\ntry: await pyrun(\"Path('/tmp/test.txt').write_text('nope')\")\nexcept AttributeError as e: print(f'No ok_dests: {e}')\n\nNo ok_dests: Cannot access callable: write_text\n\n\nYou can use '.' to allow writes relative to the current working directory. Path traversal attempts (../, subdir/../../) are detected and blocked, so the sandbox can’t escape the permitted directory:\n\npyrun_cwd = RunPython(ok_dests=['.'])\n\n# Writing to cwd should work\nawait pyrun_cwd(\"Path('test_cwd_ok.txt').write_text('hello')\")\n\n{'result': 5}\n\n\n\nPath('test_cwd_ok.txt').unlink(missing_ok=True)\n\nWriting to /tmp is blocked here since it’s not in ok_dests:\n\ntry: await pyrun_cwd(\"Path('/tmp/nope.txt').write_text('bad')\")\nexcept PermissionError: print(\"Blocked /tmp as expected\")\n\nBlocked /tmp as expected\n\n\nParent traversal is blocked if it resolves to a location outside ok_dests:\n\ntry: await pyrun_cwd(\"Path('../escape.txt').write_text('bad')\")\nexcept PermissionError: print(\"Blocked ../ as expected\")\n\nBlocked ../ as expected\n\n\n\nWrite policies\nWhen ok_dests is set, safepyrun uses write policies to determine how to validate each callable’s destination arguments. Three built-in policy classes cover common patterns: checking a positional or keyword argument (PosWritePolicy), checking the Path object itself (PathWritePolicy), and checking open() calls only when the mode is writable (OpenWritePolicy). You can also subclass WritePolicy to create custom checks.\nThe simplest, PosWritePolicy, checks a specific positional or keyword argument against the allowed destinations. Here, position 1 (or keyword dst) is validated — writing to /tmp is allowed, but /root is blocked:\n\npp = PosWritePolicy(1, 'dst')\npp.check(None, ['src', '/tmp/ok'], {}, ['/tmp'])\ntry: pp.check(None, ['src', '/root/bad'], {}, ['/tmp'])\nexcept PermissionError: print(\"PosWritePolicy correctly blocked /root/bad\")\n\nPosWritePolicy correctly blocked /root/bad\n\n\nYou can create custom write policies by subclassing WritePolicy and implementing the check method. For example, here we show a policy that only allows writes to files with specific extensions — useful if you want the LLM to create .csv or .json files but not arbitrary scripts.\nThe check signature receives (obj, args, kwargs, ok_dests) where obj is the object the method is called on (e.g. a Path instance), args/kwargs are the method’s arguments, and ok_dests is the list of permitted directory prefixes. Calling chk_dest first handles the directory check, then the custom logic adds the extension constraint on top.\n\nclass ExtWritePolicy(WritePolicy):\n    \"Only allow writes to paths with specified extensions\"\n    def __init__(self, exts): self.exts = set(exts)\n    def check(self, obj, args, kwargs, ok_dests):\n        chk_dest(obj, ok_dests)\n        if Path(str(obj)).suffix not in self.exts: raise PermissionError(f\"{Path(str(obj)).suffix!r} not allowed\")\n\n\nep = ExtWritePolicy(['.csv', '.json'])\nep.check(Path('/tmp/data.csv'), [], {}, ['/tmp'])\ntry: ep.check(Path('/tmp/script.sh'), [], {}, ['/tmp'])\nexcept PermissionError: print(\"ExtWritePolicy correctly blocked .sh\")\n\nExtWritePolicy correctly blocked .sh\n\n\nYou can register it with allow_write just like the built-in policies. The key is the ClassName.method string the sandbox will intercept:\n\nallow_write({'Path.write_text': ExtWritePolicy(['.csv', '.json', '.txt'])})",
    "crumbs": [
      "safepyrun"
    ]
  },
  {
    "objectID": "index.html#configuration",
    "href": "index.html#configuration",
    "title": "safepyrun",
    "section": "Configuration",
    "text": "Configuration\nsafepyrun loads an optional user config from {xdg_config_home}/safepyrun/config.py at import time, after all defaults are registered. This lets you permanently extend the sandbox allowlists without modifying the package. The config file is executed with all safepyrun.core globals already available, so no imports are needed. This includes allow, allow_write, WritePolicy, PathWritePolicy, PosWritePolicy, OpenWritePolicy, and all standard library modules already imported by the module.\nExample ~/.config/safepyrun/config.py (Linux) or ~/Library/Application Support/safepyrun/config.py (macOS):\nimport pandas\n\n# Add pandas tools\nallow({pandas.DataFrame: ['head', 'describe', 'info', 'shape']})\n\n# Allow pandas to write CSV to ~/data\nallow_write({'DataFrame.to_csv': PosWritePolicy(0, 'path_or_buf')})\nIf the config file has errors, a warning is emitted and the defaults remain intact.",
    "crumbs": [
      "safepyrun"
    ]
  }
]