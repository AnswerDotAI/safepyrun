# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_core.ipynb.

# %% auto #0
__all__ = ['all_builtins', 'ALLOWED_DUNDERS', 'find_var', 'allow', 'chk_dest', 'WritePolicy', 'PosWritePolicy', 'PathWritePolicy',
           'OpenWritePolicy', 'allow_write', 'SafeTransformer', 'RunPython', 'safe_type']

# %% ../nbs/00_core.ipynb #468aa264
from fastcore.utils import *
from fastcore.xtras import asdict
from fastcore.xdg import xdg_config_home
from inspect import currentframe,Parameter,signature
from contextvars import ContextVar

import json,importlib,linecache,re,inspect,uuid,ast,warnings,collections,time,asyncio,urllib.parse,dataclasses,shlex,urllib
import zlib,unicodedata,binascii,enum,secrets,pickle,contextlib,types,keyword,httpx
import heapq, bisect, html, struct, decimal, fractions, pprint, fnmatch, base64
import random, statistics, difflib, csv, string, textwrap, hashlib, copy, datetime as dt_mod
import xml.etree.ElementTree as ET,ipaddress,colorsys,cmath,traceback,sys,shutil
from datetime import datetime
from urllib.parse import quote,unquote,urlencode
from io import StringIO,BytesIO
from collections import Counter,deque

# %% ../nbs/00_core.ipynb #f178e529
from fastcore.imports import __llmtools__
from RestrictedPython import utility_builtins, safe_builtins,limited_builtins
from RestrictedPython.transformer import RestrictingNodeTransformer, INSPECT_ATTRIBUTES, copy_locations
from restrictedpython_async import *

# %% ../nbs/00_core.ipynb #16c25d79
# ContextVar fallback for when stack walking fails (e.g. inside asyncio.gather)
_rp_globals = ContextVar('_rp_globals', default=None)

def _find_frame_dict(sentinel:str):
    "Find the globals dict containing sentinel, or calling frame's globals if no sentinel"
    frame = currentframe().f_back.f_back
    if not sentinel: return frame.f_globals
    while frame:
        if sentinel in frame.f_globals: return frame.f_globals
        frame = frame.f_back
    # Fall back to RunPython globals stored in ContextVar (e.g. from asyncio.gather)
    rpg = _rp_globals.get()
    if rpg and sentinel in rpg: return rpg
    return globals()


# %% ../nbs/00_core.ipynb #99383e45
def find_var(var:str):
    "Search for var in all frames of the call stack"
    return _find_frame_dict(var)[var]

# %% ../nbs/00_core.ipynb #947e6c21
__pytools__ = {'pyrun'}

def allow(*c):
    for o in c:
        if isinstance(o, dict):
            __pytools__.update({k.__name__ for k in o})
            __pytools__.update({f'{k.__name__}.{m}' for k,v in o.items() for m in v})
        else: __pytools__.add(o)

# %% ../nbs/00_core.ipynb #eb580254
def chk_dest(p, ok_dests):
    resolved = str(Path(p).resolve())
    if not any(resolved == (rd := str(Path(d).resolve())) or resolved.startswith(rd + '/') for d in ok_dests):
        raise PermissionError(f"Write to '{p}' not allowed; permitted: {ok_dests}")

# %% ../nbs/00_core.ipynb #8146b916
class WritePolicy:
    "Base for write destination policies"
    def check(self, obj, args, kwargs, ok_dests): raise NotImplementedError

class PosWritePolicy(WritePolicy):
    "Check positional/keyword arg is an allowed write destination"
    def __init__(self, pos=0, kw=None): store_attr()
    def check(self, obj, args, kwargs, ok_dests):
        p = kwargs.get(self.kw) if self.kw and self.kw in kwargs else args[self.pos] if self.pos < len(args) else None
        if p is not None: chk_dest(p, ok_dests)

class PathWritePolicy(WritePolicy):
    "Check resolved Path self, optionally also target args"
    def __init__(self, target_pos=None, target_kw=None): store_attr()
    def check(self, obj, args, kwargs, ok_dests):
        chk_dest(obj, ok_dests)
        if self.target_pos is not None and self.target_pos < len(args): chk_dest(args[self.target_pos], ok_dests)
        if self.target_kw and self.target_kw in kwargs: chk_dest(kwargs[self.target_kw], ok_dests)

class OpenWritePolicy(WritePolicy):
    "Check open() only when mode is writable"
    def check(self, obj, args, kwargs, ok_dests):
        mode = kwargs.get('mode', args[1] if len(args) > 1 else 'r')
        if any(c in mode for c in 'wax+'): chk_dest(args[0] if args else kwargs.get('file'), ok_dests)

# %% ../nbs/00_core.ipynb #bc2debd2
__pytools_write__ = {}

def allow_write(policies):
    "Register write policies for method/function names"
    __pytools_write__.update(policies)

# %% ../nbs/00_core.ipynb #703cdc90
class _WriteChecked:
    "Wrap a method to enforce its WritePolicy before calling"
    def __init__(self, obj, method, policy, ok_dests): self.obj,self.method,self.policy,self.ok_dests = obj,method,policy,ok_dests
    def __call__(self, *args, **kwargs):
        self.policy.check(self.obj, args, kwargs, self.ok_dests)
        return self.method(*args, **kwargs)

# %% ../nbs/00_core.ipynb #2a097981
_open_policy = OpenWritePolicy()

def _safe_open(ok_dests):
    def _open(*args, **kwargs):
        _open_policy.check(None, args, kwargs, ok_dests)
        return open(*args, **kwargs)
    return _open

# %% ../nbs/00_core.ipynb #12f3bde3
all_builtins = safe_builtins | utility_builtins | limited_builtins | async_builtins | dict(
    dict=dict, list=list, set=set, tuple=tuple, frozenset=frozenset,
    iter=iter, next=next,
    __import__=__import__
)

# %% ../nbs/00_core.ipynb #069afe1c
def _make_safe_getattr(ok_dests=None):
    def _safe_getattr(obj, name):
        val = getattr(obj, name)
        if callable(val):
            keys = [f"{cls.__name__}.{name}" for cls in type(obj).__mro__]
            keys += [f"{cls.__module__}.{cls.__qualname__}.{name}" for cls in type(obj).__mro__ if hasattr(cls, '__module__')]
            obj_name = getattr(obj, '__name__', None)
            if obj_name: keys.append(f"{obj_name}.{name}")
            if ok_dests is not None:
                for k in keys:
                    if k in __pytools_write__: return _WriteChecked(obj, val, __pytools_write__[k], ok_dests)
            if not any(k in (__llmtools__|__pytools__) for k in keys): raise AttributeError(f"Cannot access callable: {name}")
        return val
    return _safe_getattr

# %% ../nbs/00_core.ipynb #6becac3b
class _DirectPrint:
    def __init__(self, *a, **kw): pass
    def _call_print(self, *a, **kw): print(*a, **kw)
    def __call__(self, *a, **kw): print(*a, **kw)

# %% ../nbs/00_core.ipynb #6eeed34a
class _Uncallable:
    def __init__(self, o, name):
        functools.update_wrapper(self, o)
        self._o,self._name = o,name
    def __call__(self, *a, **kw): raise PermissionError(f"Calling `{self._name}` is not permitted")
    def __getattr__(self, name): return getattr(self._o, name)
    def __repr__(self): return repr(self._o)

def _callable_ok(k, v, _ok):
    if k.endswith('_') or k in _ok: return True
    mod,qn = getattr(v, '__module__', None), getattr(v, '__qualname__', None)
    return bool(mod and qn and f"{mod}.{qn}" in _ok)

# %% ../nbs/00_core.ipynb #3e4ede6c
ALLOWED_DUNDERS = {'__name__', '__module__', '__doc__', '__qualname__', '__file__'}

class SafeTransformer(RestrictingNodeTransformer):
    def visit_Attribute(self, node):
        if node.attr.startswith('_') and node.attr != '_' and node.attr not in ALLOWED_DUNDERS:
            self.error(node, f'"{node.attr}" is an invalid attribute name because it starts with "_".')
        if node.attr.endswith('__roles__'):
            self.error(node, f'"{node.attr}" is an invalid attribute name because it ends with "__roles__".')
        if node.attr in INSPECT_ATTRIBUTES:
            self.error(node, f'"{node.attr}" is a restricted name, that is forbidden to access in RestrictedPython.')
        if isinstance(node.ctx, ast.Load):
            node = self.node_contents_visit(node)
            new_node = ast.Call(func=ast.Name('_getattr_', ast.Load()), args=[node.value, ast.Constant(node.attr)], keywords=[])
            copy_locations(new_node, node)
            return new_node
        elif isinstance(node.ctx, (ast.Store, ast.Del)):
            node = self.node_contents_visit(node)
            new_value = ast.Call(func=ast.Name('_write_', ast.Load()), args=[node.value], keywords=[])
            copy_locations(new_value, node.value)
            node.value = new_value
            return node
        else: raise NotImplementedError(f"Unknown ctx type: {type(node.ctx)}")

# %% ../nbs/00_core.ipynb #55cc6157
async def _run_python(code:str, g=None, ok_dests=None, concise=True):
    _rp_globals.set(g)
    _ok = __llmtools__|__pytools__
    tools = {k:(v if not callable(v) or _callable_ok(k,v,_ok) else _Uncallable(v,k))
        for k,v in g.items() if not k.startswith('_')}
    def unpack(a,*args): return list(a)
    builtins = dict(all_builtins)
    if ok_dests is not None:
        safe_open = _safe_open(ok_dests)
        builtins['open'] = safe_open
    rg = dict(__builtins__=builtins, _getattr_=_make_safe_getattr(ok_dests),
              _getitem_=lambda o,k: o[k], _getiter_=iter, _apply_ = lambda f, *a, **kw: f(*a, **kw),
              _print_=_DirectPrint, _print=_DirectPrint(),
              _unpack_sequence_=unpack, _iter_unpack_sequence_=unpack,
              enumerate=enumerate, sorted=sorted, reversed=reversed, max=max, min=min, **tools)
    if ok_dests is not None: rg['open'] = safe_open
    loc,errs = {},[]
    sout, serr = StringIO(), StringIO()
    async def run(src, is_exec=True):
        try:
            comp = compile_restricted(src, '<tool>', 'exec' if is_exec else 'eval', policy=SafeTransformer)
            res = eval(comp, rg, loc)
            if inspect.iscoroutine(res): res = await res
            return res
        except SyntaxError as e: errs.append(f'SyntaxError: {e}')
        except NameError as e: errs.append(f'`{e.name}` is not available in this sandbox; ask the user to add it to the available tools')
    def _export(): g.update({k:v for k,v in loc.items() if k.endswith('_') and not k.startswith('_')})
    def _result(res=None):
        _export()
        d = {}
        if (out := sout.getvalue()): d['stdout'] = out
        if (err := serr.getvalue()): d['stderr'] = err
        if errs: d['errors'] = '\n'.join(errs)
        if res is not None: d['result'] = res
        if concise and len(d)==1: # only one part
            if 'stdout' in d: return d['stdout']
            if 'result' in d: return d['result']
        return d or None
    tree = ast.parse(code)
    with contextlib.redirect_stdout(sout), contextlib.redirect_stderr(serr), warnings.catch_warnings():
        warnings.filterwarnings('ignore', category=SyntaxWarning)
        if tree.body and isinstance(tree.body[-1], ast.Expr):
            last = tree.body.pop()
            if tree.body:
                await run(ast.unparse(ast.Module(tree.body, [])))
                if errs: return _result()
            res = await run(ast.unparse(ast.Expression(last.value)), False)
            return _result(res)
        await run(code)
        return _result()

# %% ../nbs/00_core.ipynb #4b971b78
class RunPython:
    def __init__(self, g=None, sentinel=None, ok_dests=None):
        if not g: g = _find_frame_dict(sentinel)
        self.g,self.ok_dests = g,ok_dests

    @property
    def __doc__(self):
        tools = ', '.join(sorted(__llmtools__|__pytools__))
        return f"""Execute restricted Python with access to LLM tools, returning dict of last expression, stdout, stderr, and errors.
            If `concise`, then if just 'stdout' or 'result' returned, return only that without creating a dict.
            `import` works in the usual way. All non-callable globals and non-callable attrs are usable.
            Callable globals are also usable if their name ends with `_` (but not `_`-prefixed).
            - This is an easy way for users to expose extra functions: `def my_helper_(...)`
            Callable object attrs are only accessible if `ClassName.method` is registered as a tool.
            Multiline code blocks can be used, including defining functions and variables, for use within the call.
            In addition most builtins are available, plus these symbols: {tools}

            **NB**: If `code` creates symbols that end with `_`, they will be exported by to the calling namespace.
            - This is how you can use symbols that either human or AI can use again later.
            Examples: `len([1,2,3])` (builtin); `add_msg(content="hi")` (tool); `df.shape` (non-callable attr);
            `[x**2 for x in range(5)]` (last expression returned); `sorted(my_dict.items())` (builtin + non-callable attr)"""

    async def __call__(self, code:str, concise:bool=True):
        return await _run_python(code, g=self.g, ok_dests=self.ok_dests, concise=concise)

# %% ../nbs/00_core.ipynb #2303931f
def safe_type(o:object):
    "Same as `type(o)`"
    return type(o)

# %% ../nbs/00_core.ipynb #7df0c1fe
_io_meths = ['getvalue', 'read', 'write', 'seek']

# %% ../nbs/00_core.ipynb #1d75894f
from io import TextIOWrapper,BufferedWriter,BufferedRandom,FileIO

# %% ../nbs/00_core.ipynb #2c753931
_file_meths = ['read','readline','readlines','write','writelines','seek','tell','close','flush']
allow({TextIOWrapper: _file_meths, BufferedWriter: _file_meths, BufferedRandom: _file_meths, FileIO: _file_meths})

# %% ../nbs/00_core.ipynb #67713a82
allow({
    re: ['search', 'findall', 'sub', 'match', 'compile', 'split', 'escape', 'fullmatch', 'subn'],
    json: ['loads', 'dumps', 'load'],
    math: ['sqrt', 'floor', 'ceil', 'log', 'log2', 'log10', 'gcd', 'isnan', 'isinf',
        'exp', 'sin', 'cos', 'tan', 'atan2', 'radians', 'degrees', 'factorial', 'comb', 'perm', 'prod', 'isclose',
        'fsum', 'hypot', 'isfinite', 'copysign'],
    collections: ['Counter', 'defaultdict', 'deque', 'namedtuple', 'OrderedDict', 'ChainMap'],
    tuple: ['index', 'count'],
    float: ['is_integer', 'fromhex'],
    Counter: ['most_common'],
    dict: ['keys', 'values', 'items', 'get', 'update', 'pop', 'setdefault', 'copy'],
    list: ['append', 'copy', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort', 'count'],
    set: ['add', 'discard', 'intersection', 'union', 'difference', 'update',
        'symmetric_difference', 'issubset', 'issuperset', 'copy', 'pop', 'remove'],
    str: ['split', 'join', 'replace', 'strip', 'lstrip', 'rstrip', 'startswith', 'endswith', 'lower', 'upper',
        'find', 'count', 'format', 'isdigit', 'isalpha', 'title', 'encode', 'splitlines', 'removeprefix', 'removesuffix',
        'zfill', 'center', 'ljust', 'rjust', 'maketrans', 'translate', 'casefold', 'partition', 'rpartition'],
    bytes: ['decode', 'fromhex', 'hex'],
    int: ['to_bytes', 'from_bytes', 'bit_length'],
    Path: ['read_text', 'glob', 'iterdir', 'exists', 'read_bytes', 'is_file', 'is_dir', 'stat', 'resolve',
        'with_suffix', 'with_name', 'relative_to', 'match', 'joinpath'],
    asyncio: ['gather'], copy: ['deepcopy'], httpx: ['get', 'options'],
    itertools: ['chain', 'islice', 'groupby', 'product', 'permutations', 'combinations', 'accumulate', 'starmap', 'zip_longest',
        'pairwise', 'takewhile', 'dropwhile', 'filterfalse', 'compress', 'count', 'repeat', 'cycle', 'tee', 'batched'],
    functools: ['reduce', 'partial', 'lru_cache', 'cache', 'wraps', 'cmp_to_key', 'total_ordering'],
    textwrap: ['dedent', 'indent', 'wrap', 'shorten', 'fill'],
    datetime: ['now', 'fromisoformat', 'strftime', 'strptime', 'isoformat'],
    dt_mod: ['timedelta', 'date', 'time', 'timezone'],
    operator: ['itemgetter', 'attrgetter', 'add', 'mul', 'sub', 'truediv', 'neg', 'contains',
        'getitem', 'mod', 'eq', 'ne', 'lt', 'gt', 'or_', 'and_', 'not_', 'pow', 'floordiv', 'xor'],
    frozenset: ['intersection', 'union', 'difference', 'symmetric_difference', 'issubset', 'issuperset', 'copy'],
    StringIO: _io_meths, BytesIO: _io_meths,
    }, 'urlencode', 'quote', 'unquote', 'string', 'safe_type'
)

# %% ../nbs/00_core.ipynb #67b9faa7
allow({
    os.path: ['join', 'basename', 'dirname', 'splitext', 'exists', 'isfile', 'isdir', 'abspath',
        'relpath', 'expanduser', 'normpath'],
    base64: ['b64encode', 'b64decode', 'urlsafe_b64encode', 'urlsafe_b64decode'],
    hashlib: ['md5', 'sha256'],
    random: ['choice', 'randint', 'sample', 'shuffle', 'uniform', 'random'],
    statistics: ['mean', 'median', 'stdev'],
    difflib: ['unified_diff', 'ndiff'],
    csv: ['reader', 'DictReader'],
    heapq: ['nlargest', 'nsmallest', 'heappush', 'heappop'],
    bisect: ['bisect_left', 'bisect_right', 'insort'],
    html: ['escape', 'unescape'],
    struct: ['pack', 'unpack'],
    fnmatch: ['fnmatch', 'filter'],
    time: ['time', 'perf_counter'],
    urllib.parse: ['urlparse', 'parse_qs', 'parse_qsl', 'urlunparse', 'urljoin', 'quote_plus', 'unquote_plus'],
    dataclasses: ['dataclass', 'field', 'asdict', 'fields', 'replace', 'is_dataclass'],
    shlex: ['split', 'quote'],
    zlib: ['compress', 'decompress', 'crc32'],
    unicodedata: ['name', 'lookup', 'category', 'normalize'],
    binascii: ['hexlify', 'unhexlify'],
    enum: ['Enum', 'IntEnum'],
    secrets: ['token_hex', 'token_urlsafe'],
    deque: ['appendleft', 'popleft', 'rotate', 'extendleft'],
    ast: ['literal_eval', 'parse', 'dump', 'walk', 'unparse'],
    pickle: ['loads', 'dumps'],
    contextlib: ['suppress', 'contextmanager'],
    inspect: ['getsource', 'getsourcefile', 'getsourcelines', 'getmodule', 'getdoc', 'getmembers',
        'signature', 'isclass', 'isfunction', 'ismethod', 'ismodule', 'getfile'],
    keyword: ['iskeyword', 'kwlist'],
    ET: ['fromstring', 'tostring'],
    ET.Element: ['findall', 'find', 'get', 'iter'],
    ipaddress: ['ip_address', 'ip_network'],
    colorsys: ['rgb_to_hsv', 'hsv_to_rgb', 'rgb_to_hls'],
    cmath: ['phase', 'polar', 'rect', 'sqrt'],
    decimal: ['Decimal'], fractions: ['Fraction'],
    uuid: ['uuid4'], pprint: ['pformat'], types: ['SimpleNamespace'],
    traceback: ['format_exc'], sys: ['getsizeof'], warnings: ['warn'],
})

# %% ../nbs/00_core.ipynb #2324abe0
_path_wp = PathWritePolicy()
_dst1 = PosWritePolicy(1, 'dst')

allow_write({
    'Path.write_text': _path_wp, 'Path.write_bytes': _path_wp, 'Path.mkdir': _path_wp, 'Path.touch': _path_wp,
    'Path.unlink': _path_wp, 'Path.rmdir': _path_wp, 'Path.chmod': _path_wp, 'Path.symlink_to': _path_wp, 'Path.hardlink_to': _path_wp,
    'Path.rename': PathWritePolicy(target_pos=0, target_kw='target'),
    'Path.replace': PathWritePolicy(target_pos=0, target_kw='target'),
    'shutil.copy': _dst1, 'shutil.copy2': _dst1, 'shutil.copytree': _dst1, 'shutil.move': _dst1,
    'shutil.rmtree': PosWritePolicy(0, 'path'),
})

# %% ../nbs/00_core.ipynb #e2c7e67d
_cfg_py = xdg_config_home() / 'safepyrun' / 'config.py'
if _cfg_py.exists():
    try: exec(_cfg_py.read_text(), {k:v for k,v in globals().items() if not k.startswith('_')})
    except Exception as e: warnings.warn(f"Failed to load {_cfg_py}: {e}")
